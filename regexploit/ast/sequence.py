from dataclasses import dataclass
from typing import List, Optional

from regexploit.ast.char import Character


@dataclass(frozen=True)
class Sequence:
    elements: List

    @property
    def starriness(self):
        return sum(e.starriness for e in self.elements)

    def __len__(self):
        return len(self.elements)

    def example(self) -> str:
        return "".join(e.example() for e in self.elements)

    @property
    def minimum_length(self) -> int:
        accum: int = 0
        for e in self.elements:
            accum += e.minimum_length
        return accum

    def exact_character_class(self) -> Optional[Character]:
        """
        aa*a -> a, abc -> None, [ab][abc] -> None
        """
        first = self.elements[0].exact_character_class()
        if first is None:
            return None
        for c in self.elements[1:]:
            if c != first:
                return None
        return c

    def overall_character_class(self) -> Optional[Character]:
        """
        aa*a -> a, abc -> None, [ab][abc] -> [ab]
        """
        c = Character.ANY()
        for e in self.elements:
            c &= e.overall_character_class()
            if not c:
                return None
        return c

    def maximal_character_class(self) -> Character:
        """
        Only useful when this Sequence is inside a Repeat
        a*b -> [ab], ab* -> [ab]
        Since forcing backtracking for (bc*)$
        """
        c = None
        for e in self.elements:
            c = e.maximal_character_class() | c
        return c

    def __repr__(self) -> str:
        return "SEQ{ " + " ".join(str(e) for e in self.elements) + " }"
