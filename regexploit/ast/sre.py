import sre_constants
import sre_parse
from typing import List, Optional, Set, Tuple, Union

from regexploit.ast.at import EndOfString
from regexploit.ast.branch import Branch, make_branch
from regexploit.ast.categories import Category, covers_any
from regexploit.ast.char import Character
from regexploit.ast.groupref import subpattern_to_groupref
from regexploit.ast.repeat import FiniteRepeat, InfiniteRepeat
from regexploit.ast.sequence import Sequence

SreConstant = sre_constants._NamedIntConstant
SreOpData = Union[Tuple, List, int, SreConstant, None]
SreOp = Tuple[SreConstant, SreOpData]


class SreOpParser:
    def __init__(self):
        self._groups = {}

    def parse_sre(self, pattern: str, flags: int = 0):
        return self.sequence_or_singleton(sre_parse.parse(pattern, flags))

    def parse_op(self, op: SreConstant, data: SreOpData):
        return getattr(self, f"from_{op.name}")(data)

    def sequence_or_singleton(self, ops: List[SreOp]):
        elems = []
        for p in (self.parse_op(*op) for op in ops):
            if p is not None:
                if isinstance(p, Sequence):
                    elems.extend(p.elements)
                else:
                    elems.append(p)
        if len(elems) == 0:
            return None
        if len(elems) == 1:
            return elems[0]
        return Sequence(elems)

    def from_SUBPATTERN(self, data: Tuple[int, int, int, List[SreOp]]):
        ref = data[0]
        elements = data[3]
        result = self.sequence_or_singleton(elements)
        self._groups[ref] = result
        return result

    def from_MAX_REPEAT(
        self,
        data: Tuple[
            int,
            Union[int, SreConstant],
            List[SreOp],
        ],
    ) -> Union[FiniteRepeat, InfiniteRepeat, Branch, None]:
        minimum, maximum, elements = data
        infinite = maximum is sre_constants.MAXREPEAT
        repeatable = self.sequence_or_singleton(elements)
        if repeatable is None:
            return None
        if (
            minimum == 0
            and maximum == 1
            and repeatable.starriness
            and not repeatable.overall_character_class()
        ):
            # Interesting (starry) optional sequences as branches (ab*)? -> (ab*|)
            return make_branch([repeatable, None])
        if infinite:
            return InfiniteRepeat(repeatable, minimum)
        return FiniteRepeat(repeatable, minimum, maximum)

    def from_MIN_REPEAT(self, data):
        return self.from_MAX_REPEAT(data)

    def from_BRANCH(
        self, data: Tuple[None, List[List[SreOp]]]
    ) -> Union[Branch, FiniteRepeat, Character, None]:
        # sre already transforms (a|b|c) -> [abc]
        branches = data[1]
        return make_branch([self.sequence_or_singleton(branch) for branch in branches])

    @staticmethod
    def from_AT(at: SreConstant):
        # TODO: handling for multiline
        # TODO: handling for \\b
        if at is sre_constants.AT_END:
            return EndOfString()
        return None

    @staticmethod
    def from_ANY(_: None) -> Character:
        return Character.ANY()

    @staticmethod
    def from_LITERAL(literal: int) -> Character:
        return Character.LITERAL(literal)

    @staticmethod
    def from_NOT_LITERAL(not_literal: int) -> Character:
        return Character(literals={not_literal}, positive=False)

    @staticmethod
    def from_IN(data: List[SreOp]) -> Character:
        literals: Optional[Set[int]] = None
        categories: Optional[Set] = None
        positive = True
        if len(data) > 1 and data[0] == (sre_constants.NEGATE, None):
            positive = False
            data = data[1:]
        for in_op, in_data in data:
            if in_op is sre_constants.LITERAL:
                if literals is None:
                    literals = set()
                literals.add(in_data)
            elif in_op is sre_constants.RANGE:
                if literals is None:
                    literals = set()
                min_val, max_val = in_data
                literals.update(range(min_val, max_val + 1))
            elif in_op is sre_constants.CATEGORY:
                if categories is None:
                    categories = set()
                categories.add(Category[in_data.name[9:]])

        if categories and covers_any(categories):
            return Character.ANY() if positive else None
        return Character(literals, categories, positive)

    def from_GROUPREF(self, ref: int):
        return subpattern_to_groupref(self._groups.get(ref))

    @staticmethod
    def from_GROUPREF_EXISTS(_) -> None:
        return None  # No intention to implement this properly

    @staticmethod
    def from_ASSERT(_) -> None:
        return None  # No intention to implement this properly

    @staticmethod
    def from_ASSERT_NOT(_) -> None:
        return None  # No intention to implement this properly
