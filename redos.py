from dataclasses import dataclass
from typing import Optional, List, Tuple, Any

from repeat import InfiniteRepeat
from char import Character
from sequence import Sequence


@dataclass(frozen=True)
class Redos:
    starriness: int
    sequence_start: int
    backtrack_at: int
    repeated_character: Character
    example_prefix: str
    killer: Optional[Character]

    def example(self) -> str:
        pump = self.repeated_character.example()
        e = f"'{self.example_prefix}' + '{pump}' * 3500"
        if self.killer:
            return e + f" + '{self.killer.example()}'"
        return e


def find_redos(seq: Sequence):
    for i, elem in enumerate(seq.elements):
        # TODO branches
        if isinstance(elem, InfiniteRepeat) and (c := elem.overall_character_class()):
            print("new start", i, elem)
            yield from make_redos(seq, i, i + 1, c, elem.starriness)
            
def make_redos(seq: Sequence, sequence_start: int, continue_from: int, repeated_character: Character, starriness: int):
    # TODO branches
    # And we're off
    print(sequence_start, continue_from, repeated_character, starriness)
    for current_index in range(continue_from, len(seq.elements)):
        elem = seq.elements[current_index]
        print(current_index, elem)
        new_c = repeated_character & elem.overall_character_class()

        # Handle optional elements
        if elem.minimum_length == 0:
            if isinstance(elem, InfiniteRepeat):
                # If we have a*, we branch and try with and without it
                if new_c != repeated_character:
                    # Only branch if we have [ab]a* : if we have aa* or a[ab]* then the character class doesn't change
                    print("push branch", current_index, elem)
                    # Try without this element
                    yield from make_redos(seq, sequence_start, current_index + 1, repeated_character, starriness)
                    print("pop branch")
            else:
                continue  # Don't care about finite repeats (abc)? or a{,4}

        print(repeated_character, '+', elem.overall_character_class(), '->', new_c)
        if new_c is None:
            # This element will force backtracking as it's incompatible with `repeated_character`
            if starriness > 1:
                yield redos_found(seq, sequence_start, current_index, repeated_character, starriness, None)
            return
        
        starriness += elem.starriness
        if elem.starriness:
            print("*")
        repeated_character = new_c
    
    # Everything matched! We need to work backwards and find a 'killer' to cause backtracking if we want REDoS
    print("BACKTRACK")
    for current_index in reversed(range(continue_from, len(seq.elements))):
        elem = seq.elements[current_index]
        starriness -= elem.starriness
        if starriness <= 1:
            return
        # Can't get backtracking by not matching optional groups
        if elem.minimum_length > 0:
            # Find a character which matches the sequence and then fails on the killer
            if (match := elem.overall_character_class()) and (killer := match.negate()):
                yield redos_found(seq, sequence_start, current_index, repeated_character, starriness, killer)
                return


def redos_found(seq: Sequence, start: int, backtrack_at: int, repeated_character: Character, starriness: int, killer: Optional[Character]):        
    # TODO: Try to include some skipped optional parts (like `?`) just to make it nicer

    print("found", start, backtrack_at, repeated_character, starriness)
    redos = Redos(
        starriness,
        start,
        backtrack_at,
        repeated_character,
        Sequence(seq.elements[:start]).example(),
        killer,
    )
    print(redos.example())
    return redos