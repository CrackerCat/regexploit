import sre_constants
import string
from dataclasses import dataclass
from typing import List, Tuple, Set, Optional
import sys

from categories import in_category, EXAMPLE_FOR_CAT, covers_any, list_category, Category


@dataclass(frozen=True)
class Character:
    literals: Optional[Set[int]] = None
    categories: Optional[Set[Category]] = None
    not_literals: Optional[Set[int]] = None
    not_categories: Optional[Set[Category]] = None

    @staticmethod
    def ANY() -> "Character":
        return Character()

    @staticmethod
    def LITERAL(literal: int) -> "Character":
        return Character({literal})

    @property
    def minimum_length(self) -> int:
        return 1

    @property
    def starriness(self) -> int:
        return 0

    def exact_character_class(self) -> "Character":
        return self

    def overall_character_class(self) -> "Character":
        return self

    @property
    def is_any(self) -> bool:
        return self.literals is None and self.categories is None and self.not_literals is None and self.not_categories is None
    
    @property
    def _is_positive(self) -> bool:
        return (self.literals is not None or self.categories is not None) and self.not_literals is None and self.not_categories is None
    
    @property
    def _is_negative(self) -> bool:
        return (self.not_literals is not None or self.not_categories is not None) and self.literals is None and self.categories is None

    @property
    def _is_positive_literal(self) -> bool:
        return self.literals is not None and self.categories is None and self.not_literals is None and self.not_categories is None
    
    @property
    def _is_negative_literal(self) -> bool:
        return self.literals is None and self.categories is None and self.not_literals is not None and self.not_categories is None
    
    @property
    def _is_positive_category(self) -> bool:
        return self.literals is None and self.categories is not None and self.not_literals is None and self.not_categories is None
    
    @property
    def _is_negative_category(self) -> bool:
        return self.literals is None and self.categories is None and self.not_literals is None and self.not_categories is not None

    def expand_categories(self) -> "Character":
        """
        This is the nuclear option where we expand the categories into literals.
        Can be huge in unicode.
        """
        if self._is_positive:
            if self.categories:
                lits: Set[int] = set(self.literals) if self.literals else set()
                for c in self.categories:
                    lits.update(list_category(c))
                return Character(literals=lits)
        elif self.not_categories:
            not_lits: Set[int] = set(self.not_literals) if self.not_literals else set()
            for c in self.not_categories:
                not_lits.update(list_category(c))
            return Character(not_literals=not_lits)

        return self

    def __and__(self, other: "Optional[Character]") -> "Optional[Character]":
        if other is None:
            return None
        if self.is_any:
            return other
        if other.is_any:
            return self
        
        # [ab] & [bc] -> [c]
        if self._is_positive_literal and other._is_positive_literal:
            lits = self.literals & other.literals
            if not lits:
                return None
            return Character(literals=lits)
        if self._is_positive_category and other._is_positive_category:
            cats = self.categories & other.categories
            if not cats:
                return None
            return Character(categories=cats)
        # [^ab] & [^bc] -> [^abc]
        if self._is_negative_literal and other._is_negative_literal:
            return Character(not_literals=self.not_literals | other.not_literals)
        if self._is_negative_category and other._is_negative_category:
            categories = self.not_categories | other.not_categories
            if covers_any(categories):  # [^\d] & [^\D] = nothing
                return None
            return Character(not_categories=categories)
        # [ab] & [^bc] -> [a]
        if self._is_positive_literal and other._is_negative_literal:
            lits = self.literals - other.not_literals
            if not lits:
                return None
            return Character(literals=lits)
        if other._is_positive_literal and self._is_negative_literal:
            lits = other.literals - self.not_literals
            if not lits:
                return None
            return Character(literals=lits)

        return self.expand_categories() & other.expand_categories()

    def __rand__(self, other: "Optional[Character]") -> "Optional[Character]":
        return self & other
    
    def __repr__(self) -> str:
        if self.is_any:
            return '.'
        result = '['
        more = False
        if self.literals is not None:
            result += ",".join(f"{hex(c)[2:]}:{chr(c)}" for c in self.literals)
            more = True
        if self.categories is not None:
            if more:
                result += ';'
            result += ",".join(c.name for c in self.categories)
            more = True
        if self.not_literals is not None:
            if more:
                result += ';'
            result += 'NOT '
            result += ",".join(f"{hex(c)[2:]}:{chr(c)}" for c in self.not_literals)
            more = True
        if self.not_categories is not None:
            if more:
                result += ';'
            result += 'NOT '
            result += ",".join(c.name for c in self.not_categories)
            more = True
        return result + ']'

    def example(self) -> str:
        if self.literals:
            return chr(next(iter(self.literals)))
        elif self.categories:
            cat = sorted(self.categories, key=lambda c: 0 if c.is_positive else 1)[0]
        elif self.not_literals:
            if printables := (self.not_literals & {ord(c) for c in string.printable}):
                return chr(printables.pop())
            return chr(next(iter(self.not_literals)))
        
        raise NotImplementedError

    def negate(self) -> "Character":
        if self.is_any:
            return None
        if self._is_positive:
            return Character(not_literals=self.literals, not_categories=self.categories)
        if self._is_negative:
            return Character(literals=self.not_literals, categories=self.not_categories)
        
        raise NotImplementedError

    def contains(subgroup: "Character") -> bool:
        if self.is_any:
            return True
        if subgroup.is_any:
            return False
        if subgroup == self:
            return True

        if self._is_positive_literal and subgroup._is_positive_literal:
            return not (subgroup.literals - self.literals)
        if self._is_positive_category and subgroup._is_positive_category:
            return not (subgroup.categories - self.categories)

        return False  # Lazy, TODO: do full match