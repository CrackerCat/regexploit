import sre_constants
import sre_parse
from typing import Any, List, Optional, Set, Tuple, Union

from at import EndOfString
from branch import Branch, make_branch
from categories import Category
from char import Character
from repeat import FiniteRepeat, InfiniteRepeat
from sequence import Sequence

SreConstant = sre_constants._NamedIntConstant
SreOpData = Union[Tuple, List, int, SreConstant, None]
SreOp = Tuple[SreConstant, SreOpData]


class SreOpParser:
    @staticmethod
    def parse_sre(pattern: str, flags: int = 0):
        return SreOpParser.sequence_or_singleton(sre_parse.parse(pattern, flags))

    @staticmethod
    def parse_op(op: SreConstant, data: SreOpData):
        return getattr(SreOpParser, f"from_{op.name}")(data)

    @staticmethod
    def sequence_or_singleton(ops: List[SreOp]):
        elems = []
        for p in (SreOpParser.parse_op(*op) for op in ops):
            if p is not None:
                if isinstance(p, Sequence):
                    elems.extend(p.elements)
                else:
                    elems.append(p)
        if len(elems) == 0:
            return None
        if len(elems) == 1:
            return elems[0]
        return Sequence(elems)

    @staticmethod
    def from_SUBPATTERN(data: Tuple[int, int, int, List[SreOp]]):
        elements = data[3]
        return SreOpParser.sequence_or_singleton(elements)

    @staticmethod
    def from_MAX_REPEAT(
        data: Tuple[
            int,
            Union[int, SreConstant],
            List[SreOp],
        ]
    ) -> Union[FiniteRepeat, InfiniteRepeat, Branch, None]:
        minimum, maximum, elements = data
        infinite = maximum is sre_constants.MAXREPEAT
        repeatable = SreOpParser.sequence_or_singleton(elements)
        if repeatable is None:
            return None
        if (
            minimum == 0
            and maximum == 1
            and repeatable.starriness
            and not repeatable.overall_character_class()
        ):
            # Interesting (starry) optional sequences as branches (ab*)? -> (ab*|)
            return make_branch([repeatable, None])
        if infinite:
            return InfiniteRepeat(repeatable, minimum)
        return FiniteRepeat(repeatable, minimum, maximum)

    @staticmethod
    def from_MIN_REPEAT(data):
        return SreOpParser.from_MAX_REPEAT(data)

    @staticmethod
    def from_BRANCH(
        data: Tuple[None, List[List[SreOp]]]
    ) -> Union[Branch, FiniteRepeat, Character, None]:
        # sre already transforms (a|b|c) -> [abc]
        branches = data[1]
        return make_branch(
            [SreOpParser.sequence_or_singleton(branch) for branch in branches]
        )

    @staticmethod
    def from_AT(at: SreConstant):
        # TODO: handling for multiline
        # TODO: handling for \\b
        if at is sre_constants.AT_END:
            return EndOfString()
        return None

    @staticmethod
    def from_ANY(_: None) -> Character:
        return Character.ANY()

    @staticmethod
    def from_LITERAL(literal: int) -> Character:
        return Character.LITERAL(literal)

    @staticmethod
    def from_NOT_LITERAL(not_literal: int) -> Character:
        return Character(literals={not_literal}, positive=False)

    @staticmethod
    def from_IN(data: List[SreOp]) -> Character:
        literals: Optional[Set[int]] = None
        categories: Optional[Set] = None
        positive = True
        if len(data) > 1 and data[0] == (sre_constants.NEGATE, None):
            positive = False
            data = data[1:]
        for in_op, in_data in data:
            if in_op is sre_constants.LITERAL:
                if literals is None:
                    literals = set()
                literals.add(in_data)
            elif in_op is sre_constants.RANGE:
                if literals is None:
                    literals = set()
                min_val, max_val = in_data
                literals.update(range(min_val, max_val + 1))
            elif in_op is sre_constants.CATEGORY:
                if categories is None:
                    categories = set()
                categories.add(Category[in_data.name[9:]])

        return Character(literals, categories, positive)

    @staticmethod
    def from_GROUPREF(_) -> None:
        return None  # No intention to implement this properly

    @staticmethod
    def from_ASSERT(_) -> None:
        return None  # No intention to implement this properly

    @staticmethod
    def from_ASSERT_NOT(_) -> None:
        return None  # No intention to implement this properly
