import sre_constants
from typing import List, Tuple, Optional, Set, Any, Union

from branch import Branch, make_branch
from char import Character
from repeat import FiniteRepeat, InfiniteRepeat
from sequence import Sequence
from categories import Category


class SreOpParser:
    @staticmethod
    def parse_op(op, data):
        return getattr(SreOpParser, f"from_{op.name}")(data)

    @staticmethod
    def sequence_or_singleton(ops: List[Tuple[sre_constants._NamedIntConstant, Any]]):
        elems = [p for p in (SreOpParser.parse_op(*op) for op in ops) if p is not None]
        if len(elems) == 0:
            return None
        if len(elems) == 1:
            return elems[0]
        return Sequence(elems)

    @staticmethod
    def from_SUBPATTERN(data: Tuple[int, int, int, List[Tuple[sre_constants._NamedIntConstant, Any]]]):
        elements = data[3]
        return SreOpParser.sequence_or_singleton(elements)
    
    @staticmethod
    def from_MAX_REPEAT(data: Tuple[int, Union[int, sre_constants._NamedIntConstant], List[Tuple[sre_constants._NamedIntConstant, Any]]]) -> Union[FiniteRepeat, InfiniteRepeat, None]:
        minimum, maximum, elements = data
        repeatable = SreOpParser.sequence_or_singleton(elements)
        if repeatable is None:
            return None
        if maximum is sre_constants.MAXREPEAT:
            return InfiniteRepeat(repeatable, minimum)
        return FiniteRepeat(repeatable, minimum, maximum)

    @staticmethod
    def from_MIN_REPEAT(data):
        return SreOpParser.from_MAX_REPEAT(data)

    @staticmethod
    def from_BRANCH(data: Tuple[None, List[Tuple]]) -> Union[Branch, FiniteRepeat, Character, None]:
        # sre already transforms (a|b|c) -> [abc]
        branches = data[1]
        return make_branch([
            SreOpParser.sequence_or_singleton(branch) for branch in branches
        ])

    @staticmethod
    def from_ANY(_: None) -> Character:
        return Character.ANY()

    @staticmethod
    def from_LITERAL(literal: int) -> Character:
        return Character.LITERAL(literal)
    
    @staticmethod
    def from_NOT_LITERAL(not_literal: int) -> Character:
        return Character(not_literals={not_literal})

    @staticmethod
    def from_IN(data: List[Tuple]) -> Character:
        literals: Optional[Set[int]] = None
        categories: Optional[Set] = None
        positive = True
        if len(data) > 1 and data[0] == (sre_constants.NEGATE, None):
            positive = False
            data = data[1:]
        for in_op, in_data in data:
            if in_op is sre_constants.LITERAL:
                if literals is None:
                    literals = set()
                literals.add(in_data)
            elif in_op is sre_constants.RANGE:
                if literals is None:
                    literals = set()
                min_val, max_val = in_data
                literals.update(range(min_val, max_val + 1))
            elif in_op is sre_constants.CATEGORY:
                if categories is None:
                    categories = set()
                categories.add(Category[in_data.name[9:]])

        if positive:
            return Character(
                literals, categories,
                None, None,
            )
        return Character(
            None, None,
            literals, categories,
        )